// @import 'init';

// Maxx
// ====
// Ultimate 300/300: 100%
// Ultimate 200/300: 66%
// Ultimate 100/300: 33%
// Extreme 50/300  : 16.6%
// Non-maxx
// ========
// Ultimate 50/50  : 100%
// Extreme 30/50   : 60%
// Turbo 20/50     : 40%
// Standard 15/50  : 30%;
$needle-height: 112px;
$needle-top-height: 106px;
$needle-width: 12px;
$needle-color: #666;
$circle-radius: 95px;
$circle-diameter: $circle-radius * 2;
$circle-color-bg: #f3f6f9;
$circle-color-bg: #e0f3fc;
$circle-color-speed: #0590dd;
$circle-color-cover: #fff;
$dial-stroke-width: 30px;
$start-pos: -180deg;
$end-pos: $start-pos + 180deg;
$end-pos-100: $end-pos;
$end-pos-66: $start-pos + 180deg * 0.666;
$end-pos-60: $start-pos + 180deg * 0.6;
$end-pos-40: $start-pos + 180deg * 0.4;
$end-pos-33: $start-pos + 180deg * 0.333;
$end-pos-30: $start-pos + 180deg * 0.3;
$end-pos-16: $start-pos + 180deg * 0.166;

// List of possible percentages
$percentages: 100, 66, 60, 40, 33, 30, 16;

// List of possible ending positions (rotations)
$end-positions: $end-pos-100, $end-pos-66, $end-pos-60, $end-pos-40, $end-pos-33, $end-pos-30, $end-pos-16;

@mixin animation {
	transform-origin: bottom center;
	animation-duration: 1s;
	animation-iteration-count: 1;
	animation-timing-function: ease-out;
	animation-fill-mode: forwards;
}

.speedometer {
	// We need to hide overflow on the container or else the rotating 'needle' boundary box will create scrollbars when animated
	overflow: hidden;

	// Add some extra space around the container so that 'needle' isn't cut off while animating
	width: $circle-diameter + 20px;
	height: $circle-radius + 25px;
	position: relative;
	margin: 20px auto;

	// contains progress bar and needle
	.dial {
		padding-top: 20px;
		overflow: hidden;
	}

	// needle is a css triangle above a css half-circle
	.needle {
		position: absolute;
		left: 0;
		right: 0;
		top: $circle-radius - $needle-height;
		top: 2px;
		width: $needle-width;
		margin: 0 auto;
		z-index: 50;

		.inner {
			height: $needle-height;
			width: $needle-width;
			position: relative;
			transform: rotate(90deg);
			transform-origin: bottom center;
		}

		.top,
		.bottom {
			position: absolute;
		}

		// upper triangle
		.top {
			top: 0;
			left: 0;
			width: 0;
			height: 0;
			border-style: solid;
			border-width: 0 ($needle-width / 2) $needle-top-height ($needle-width / 2);
			border-color: transparent transparent $needle-color transparent;
		}

		// lower half circle
		.bottom {
			height: $needle-width / 2;
			width: $needle-width;
			border-radius: 0 0 $circle-diameter $circle-diameter;
			background-color: $needle-color;
			margin: 0 auto;
			bottom: 1px;
		}
	}

	// container/clipping mask for half circles
	.bar {
		position: relative;
		overflow: hidden;
		height: $circle-radius;
	}

	.half-circle {
		height: $circle-radius;
		width: $circle-diameter;
		border-radius: $circle-diameter $circle-diameter 0 0;
		margin: 0 auto;
		position: absolute;
		left: 0;
		right: 0;
		top: 0;
		transform-origin: bottom center;
	}

	// Speed indicator/progress bar background
	.half-circle-bg {
		background-color: $circle-color-bg;
		z-index: 10;
	}

	// Speed indicator/progress bar
	.half-circle-speed {
		background-color: $circle-color-speed;
		z-index: 20;
	}

	// Speed indicator/progress bar cover, makes the half circle appear as as a circular bar instead
	.half-circle-cover {
		background-color: $circle-color-cover;
		height: $circle-radius - $dial-stroke-width;
		width: $circle-diameter - $dial-stroke-width * 2;
		border-radius: $circle-diameter $circle-diameter 0 0;
		background: $circle-color-cover;
		margin: 0 auto;
		top: $dial-stroke-width;
		z-index: 30;
	}

	.animated {
		transform: rotate($start-pos);

		@include animation;
	}
}

// Iterate over each possible percentage the progress meter will indicate
@for $i from 1 through length($percentages) {
	// Grab our percent from the list, according to the loop index
	$percent: #{nth($percentages, $i)};

	// Add a class name that corresponds to the percentage number
	.percent-#{$percent} .speedometer.play,
	// Small versions
	.percent-#{$percent}-sm .speedometer.play {
		// 'animated' is the class on elements that animate on animated version
		.animated {
			// Pull the name of the correct animation based on index
			animation-name: to-#{nth($percentages, $i)};
		}
	}

	// Class names for satic versions
	.percent-#{$percent}-static,
	// Small versions
	.percent-#{$percent}-static-sm {
		.animated {
			animation: none;

			// Pull the correct ending position based on index
			transform: rotate(#{nth($end-positions, $i)});
		}
	}
}

// Small versions. When we shrink them down there is a gap between the white half circle that is covered the blue bg circle and the bottom of the blue circle. Add a pseudo element to cover it
[class*='sm'] {
	.speedometer {
		transform: scale(0.6);

		.half-circle-cover::after {
			background-color: #fff;
			height: 10px;
			width: $circle-diameter - $dial-stroke-width * 2;
			margin: 0 auto;
			top: $dial-stroke-width * 2;
			content: '';
			position: absolute;
			border-radius: 1px;
			z-index: 40;
		}
	}
}

// Generate keyframes
@for $i from 1 through length($percentages) {
	$percent: #{nth($percentages, $i)};

	@keyframes to-#{$percent} {
		0% {
			transform: rotate($start-pos);
		}

		// translate3d for FF rendering bug
		100% {
			transform: rotate(#{nth($end-positions, $i)});
		}
	}
}
